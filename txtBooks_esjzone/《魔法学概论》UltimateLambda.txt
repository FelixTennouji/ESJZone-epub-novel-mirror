简介
并非小说, 大概可能是随笔, 小品, 散文, 怪谈之混合罢. 虽然标题是魔法学概论, 但更近于魔术学 (TYPE-MOON) 概论. 应该会有许多程式语言写成的东西, 但这是不可避免的. 作者认为, 作为精确语言, 程式语言不仅可以用来表达计算, 也能够表达一般的思想. 程序, 是供人阅读的, 附带给机器运行.
个人主页: https://alpha-beta-eta.github.io/
前言 
科幻作家克拉克曾经说过, 任何技术在不懂的人眼中都无异于魔法. 埃及人建造金字塔的技术, 是古代魔法的一个实例.
魔法虽然抽象, 却是很具体的东西. 如果你们觉得对使魔下令帮助你们写作业算是魔法的话, 那就全然误解了魔法的实质. 我指的是, 使魔压根就没有办法帮助你们写作业, 因为这个命令不够具体.
魔法的核心是抽象, 这与数学类似. 在物理中, 串联一万个放大器是荒谬的. 然而, 在魔法学中, 串联一万个魔法是相当合理的. 这是魔法相当与众不同的特点. 换句话说, 如果在现实世界中抽象是一种原理的话, 在魔法世界中, 抽象就是一种法则. 它全然就是精确的, 而不是在某种限度内近似精确的.
魔法学最重要的分支是程序设计学与魔法语言学. 前者的重要性历来被人们忽视, 而后者在魔法学中, 出于历史原因, 相当小众. 不过, 本书主要就是关于这两个领域的.
程序设计学被人们忽视的原因其实很简单, 因为写程序太简单了. 任何人都能写程序, 但不是任何人都是魔法师. 许多想成为魔法师但并不是魔法师的人们写了许多关于魔法的垃圾, 他们经常向希望学习魔法的人灌输一种错误的想法, 即要成为魔法师必须精通数据结构和算法. 数据结构和算法当然是重要的, 但并不是最重要的, 而且不是首先应该学习的. 一个新人, 最开始应该学习的东西, 应该是如何组织他的程序.
魔法语言学小众的原因其实也相当简单, 那就是这个学科有很长时间的混沌期. 那时的研究者完全不知道在做些什么, 其中偶尔有些非常聪明的人, 是他们的专著逐渐塑造了现代的魔法语言学, 那些作品至今仍有阅读的价值. 然而, 的确因为那个很长的混沌期, 使得许多人, 甚至是魔法大师, 也对于魔法语言学充满了偏见. 比如, 一些门外汉以为句法学是魔法语言学的核心, 魔法语言学不外乎是关于句法分析的学科. 魔法语言学的研究者经常怀有令人讶异的傲慢, 或许正是与这些人有关, 但这也使得魔法语言学至今很小众.
我的书试图同时讨论这两个分支学科, 并希望将它们安于适当的位置. 同时, 我也希望我的作品能够拥有永恒的价值, 而不像许多人评论道的那样, "魔法是一种每年翻新的时尚".
第一章 编程的基础
读取-求值-输出循环 
Read-Evaluate-Print Loop, 一般缩写为REPL, 直译就是读取-求值-输出循环, 是许多Scheme实现提供的一种模式. 它是绝佳的魔法试验场所, 也是学习魔法的最好方式. 其中, 你输入一个表达式, 系统就会读入它, (将其转换为句法对象,) 对它进行求值, 然后将结果直接地输出在下方, 并继续等待新的输入. 琢磨REPL的输入和输出, 是任何魔法学徒都必须进行的修炼.
鉴于REPL的形式因实现而异, 我们采取以下记法上的约定: 输入以>作为提示符, 输出直接显示在下一行. 请看以下示例:
https://telegra.ph/file/81fd22bd4a7e543fc2631.png
它的意思, 或许你已经猜到了, 它表示42这个表达式的值是42.
字面量 
一些种类的表达式的值即它们的字面本身 (虽然读者应该注意到这个说法有所简化), 所以我们将其称为字面量.
常见的字面量有数字, 布尔和字符串等.
https://telegra.ph/file/f85bbfb78978c4496b9a6.png
Scheme的实现大都支持分数 (可以视为整数的序对) 和复数 (可以视为实数的序对). 至于浮点数 (floating number) 的种种, 我们绝不打算深入涉及, 因为它偏离了我们的目的, 但这也并不困难.
Scheme使用#t表示真(true), #f表示假(false).
字符串从句法上看是用两个"括起来的字符序列.
历史注记: hello world程序是Unix文化中典型的第一个程序或者测试用程序, 但在Lisp文化 (Scheme是Lisp的一个现代方言) 中则并非如此. 有意思的是, 关于Unix文化的重要书籍The New Hacker's Dictionary (新黑客词典) 是基于反映了Lisp文化的书籍The Hacker's Dictionary (黑客词典) 篡改而成的, 而The Hacker's Dictionary的原稿源于Guy Steele在角落里发现的jargon file (行话文件). jargon file主要是作搞笑之用, 它反映了第一代黑客的原始风貌, 这与现在大众文化中的黑客的概念非常不同.
变量 
变量在字面上是符号 (或者更确切地说是标识符), 但它不代表字面, 而是引用与其关联的值. 这与数学的实践类似, 但数学文献经常混淆符号和变量, 然而在Scheme中这两者有着句法上的区别, 虽然暂时我们还不会引入符号.
我们可以用define形式将一个符号和一个值关联起来, 这就是"起名字", 一种最基本的抽象形式. 俗话有云, 如果你知道一个精灵的真名 (true name), 那么你也就能够操纵它.
https://telegra.ph/file/797fc3ce006792dfa2b60.png
注意: 在Scheme中, 过程, 或者说函数, 也是值, 或者说是可以操纵的对象. 同样地, 我们可以使用符号去引用一个过程, 但它的表示, 是因实现而定的. 这里面有很多原因, 之后我们会解释.
https://telegra.ph/file/190d0f7164cc15e68ff7f.png
+自然与一个表示数字加法的过程相关联. 这是我使用的实现 (Chez Scheme) 输出的样式.
过程应用 
过程应用 (procedure application) 的意思就是将过程应用于具体的参数上去, 而过程是函数的近义词.
一般来说我们并不区分过程和函数这两个术语, 但现在我们略微讨论一下. 现代数学意义上的函数是外延性的, 也就是说, 函数只是输入和输出的对应, 同算术, 算法和几何图形没有直接的联系. 即便一个函数由某个公式给出, 数学家也仅是将其当作序对的集合 (不过, 一个函数的资料一般还包括它的domain和codomain). 程序设计中出现的过程和函数是不同的, 因为它不仅仅是一种对应关系, 还蕴含着如何从输入计算得到输出的规则方法, 也就是说, 它更具内涵性. 在历史上, 函数的概念有着很长的发展历程, 但自从Dirichlet之后, 外延性的观念就逐渐占上风了, 并到现在完全主宰了数学领域. 但是, 随着魔法学的兴起, 内涵性的观念重新得到重视, 并且与之相关的lambda calculus等理论也得到极大发展.
传统上, 数学中函数应用的句法是多种多样的, 比如有中缀记号, 主要用于加减乘除, 前缀记号, 主要用于人们自己定义的函数, 还有一些角标记号等等. 但是, Scheme中只有一种过程应用的记号, 那就是"全加括号的前缀记号". 虽然最开始许多人会因为数学实践中养成的习惯对这种记号很不适应, 但是多加使用之后就会发现它的确是一种更加一致与方便的记号.
https://telegra.ph/file/3b1a925f5d63a423efe17.png
(remainder自然是取余数的过程, quotient自然是取商的过程.)
表示过程的记号 
显然, 我们需要一种记号来表示过程. Scheme中的这个记号一般被称为lambda表达式, 它的式样与名字, 自然是源于lambda calculus.
lambda表达式的一般句法是(lambda (<var>*) <exp>). 使用尖括号括起来的符号表示一个句法范畴, 当一个句法里出现句法范畴时, 它意在被该句法范畴的一个元素 (或者说一个实例) 所替代. 这里我们用<var>表示所有符号构成的句法范畴, <exp>表示的是所有表达式构成的句法范畴. 虽然表达式是什么样的东西我们还没有定义, 但直到我们开始讨论魔法语言学之前, 我们都认为这个概念从直觉上是可以理解的. *是Kleene star, 它跟在一个句法范畴后面, 表示零个至任意有限多个皆可.
以上的说明有些复杂, 还是举简单的例子来得容易.
https://telegra.ph/file/e66ff1bce6d4a5c467508.png
我们可以看到, 对于(lambda (x) (* x x))求值的结果是一个过程. 应用这个过程, 它的句法与之前我们见过的完全一致, 比如, 于分数1/2上, 就得到了1/4. 显然, 这个过程的意思是平方, 任何学过数学的人都能明白, x是过程的(形式)参数, (* x x)是过程的体. (之所以称这个参数是形式的, 是因为它只是一个占位符, 不具有实际的含义.)
这个lambda表达式的数学记号的对应物是
https://telegra.ph/file/2827ac2fffc5dd535f783.png
不过, 或许"令f(x)=x*x"是人们更熟悉的说法, 但是读者应该注意到, 函数不需要拥有一个名字, 这是它外在的东西.
这个记号的优点在于用它表示泛函 (functional, 这里我们指以函数为输入或输出的函数) 时, 不会显得凌乱, 反而特别规整, 比如看以下这个例子.
https://telegra.ph/file/679ce1fa5172eda8f6b77.png
这个例子乍看上去非常复杂, 但是实际上非常简单, 所以我们要分成几个步骤看待它.
首先, 第一个值得注意的部分是
https://telegra.ph/file/e5e5676baefb472e43fad.png
它先接受两个参数f和g, 这两个参数的名字实际上已经暗示了它们应该是函数, 然后返回一个函数, 它接受一个参数x, 返回(f (g x)). 对数学略知一二的读者想必已经明白这个过程表达的是函数的复合之意.
接着, 将函数的复合应用于两个实际的函数, 一个是平方, 一个是加一.
https://telegra.ph/file/c073c0b741a181eac8dfb.png
这个函数应用的结果是一个函数, 它先给参数加上一, 接着再进行平方操作.
最后, 我们将这个函数应用于实际的参数3.
https://telegra.ph/file/11c543557827946ca64e6.png
就得到了结果16.
定义 
我们之前已经见过定义了, 它也能直接地运用于过程.
https://telegra.ph/file/e7f612476f033f3e63e24.png
我们曾说"起名字"是最基本的抽象方式, 那么什么是抽象呢?
抽象有两个基本的方面, 一个方面是从各种东西中寻找共同的模式, 另一个方面是将许多概念组合成一个概念, 在思考这个概念时, 我们从整体出发, 而忽略次要的细节.
实际上, 名是提示我们概念的整体性质的助记符, 所以起名字是最基本的抽象方式.
而且, 当我们寻找到共同的模式时, 我们也往往会忍不住给它起一个名字. 然后, 我们将这个名字所蕴含的概念用于简化它所能应用的一切事物.
以下是一则典型的例子, 或许读者应该咀嚼一小会儿.
https://telegra.ph/file/8b257dd17b76ad2a1080e.png
为了避免误解, 我们应该指出, 定义的次序在某种程度上具有随意性, 比如这里pi, square和area的定义不论怎样排列都不会影响接下来(area 5)的结果. 这种自由, 在某种程度上, 可以用来提高可读性. 可读性是程序最重要的方面, 因为程序是供人阅读的.
这里area的定义基于pi和square, 这是很低矮的抽象之塔. 当然, 抽象的塔也可以搭得很高很高. 这其中的关键在于, 有的抽象仅仅是功能性的增强, 而有的抽象则在概念上提升了抽象的层次. 也就是说, 它提供了一种屏障, 让人们在思考这层抽象时没有必要思考在它之下的抽象. 这种抽象层次的划分是最朴素也最强大的控制复杂度的手段, 任何实际的工程学和抽象的工程学都离不开它. 以我之见, 魔法的许多方面是工程学, 而且是最纯粹的工程学, 因为它常常无需考虑现实的代价, 而仅仅只需要人能够想出来而已.
注记: 鉴于过程的定义经常出现, Scheme中提供了一种简化但等效的句法用于定义过程. (简化而等效的句法一般被称为句法糖.)
https://telegra.ph/file/062063d01a483bfad3d73.png
以之前上面的例子为例, 通过这个句法糖, 它可以写成如上形式.
条件分支 
条件分支表达某种形式的选择.
想一下我们在数学中是如何定义一个实数的绝对值的.
https://telegra.ph/file/14e98d043f8031adcab8e.png
我们可以直接地将其转换为一个Scheme定义.
https://telegra.ph/file/ee2911ba48ffd3cb30420.png
这里牵扯到一个if表达式, 它的一般句法形式为(if <exp> <exp> <exp>). if表达式的语义是这样的, 它先对于其第一个句法参数求值, 若为真, 则对于第二个句法参数求值, 并且整个if表达式的值就是该求值的结果, 若为假, 则对于第三个句法参数求值, 并且整个if表达式的值就是该求值的结果.
读者应该注意到, if不是一个函数, 因为它不会对它的每个参数都求值, 而是根据对于第一个参数求值的结果, 选择第二个参数和第三个参数其中一个进行求值.
Scheme中还有一个非常常用的条件分支表达式, 名为cond.
其一般的句法形式为(cond (<exp> <exp>) ... (else <exp>)).
为了透明性, 我们应该对于省略号的意图做说明, 它表示前一个子句法形式出现零个至任意有限多个, 也就是说, 它和Kleene star其实是一样的, 只是看起来不同罢了, cond的句法形式也可以表达为(cond (<exp> <exp>)* (else <exp>)).
cond的语义十分简单, 它先对于第一个表达式对的第一个句法参数求值, 若为真, 则对于该对的第二个句法参数求值, 并且将其作为整个cond表达式的值 (剩下的就不会求值了), 若为假, 则将注意力转移到第二个表达式对, 如法炮制. 另外, else在cond的上下文中被视为真, 并且只能出现在最后一个表达式对中. else也可以不出现, 但若直至最后一个对仍然无法确定cond的值的话, 该表达式的值是未刻画的, 因实现而异. 依赖于这种特定实现细节的程序是完全丑陋的, 请读者不要写出丑陋的程序.
实际上, 在绝大部分Scheme实现中, cond表达式会被规约为等价的if表达式.
以下是数学中符号函数的例子.
https://telegra.ph/file/bf38fdb84793a6d8fac40.png
其意思, 想必已经很明了了.
注记: Scheme将所有不等于#f的值视为真. 这个设计在某种意义上还是非常合理的, 但魔法语言学家肯定会拿出一堆理由反对它.
and, or, not 
Scheme中的「and, or, not」对应于「与, 或, 非」的逻辑概念, 但有一些细节值得讨论.
这其中最简单的是not, 它是一个函数. 其接受一个任意的值作为参数. 如果该值为真, 则返回#f; 如果该值为假, 则返回#t.
https://telegra.ph/file/59cbf4a476f6224ff716a.png
and和or不是函数, 因为对于and和or表达式的求值遵循短路规则.
https://telegra.ph/file/b2b787b1b3925d610ae86.png
and和or表达式都具有不定数目的句法参数, 每个句法参数都是一个表达式. (and)的值等于#t, (or)的值等于#f. 当and和or表达式只具有一个句法参数时, 该句法参数的值就是and或or表达式的值. 当它们具有大于一个的句法参数时, 它们都先对于其第一个句法参数求值. 对于and表达式而言, 这个值为#f的话, 就不需要再对于其后的表达式求值了, 因为不论其后的值如何, 整个and表达式的值都应该是#f, 所以此时and表达式会立即返回#f这个值, 否则的话, 也就是这个值为真的情况, and表达式就不再考虑这个句法参数了, 因为它对于and表达式的值不会有影响了, 转而对于下一个句法参数求值. 对于or表达式而言, 这个值为真的话, 那么整个or表达式的值就应该为真, 所以or表达式立即返回这个值, 否则的话, 也就是这个值为#f的情况, or表达式就不再考虑这个句法参数了, 因为它对于or表达式的值不会有影响了, 转而对于下一个句法参数求值. 以上是短路求值的想法, 但值得说明的是, 短路还是不短路将对于语义产生影响, 因为对于表达式的求值可能不终止, 或是对于表达式的求值会产生副作用.
文字的说明或许有些烦闷, 我们将展示一些求值的逐步过程. 以后读者遇到复杂的表达式时, 也应该采取类似的方法来帮助理解.
https://telegra.ph/file/96944646e8443b6e7eb60.png
根据短路的and和or, abs函数也可以按照如下方式定义.
https://telegra.ph/file/5695c2fc92efaab593132.png
虽然这被视为一种技巧, 但我们将此视为丑陋的, 所以永远不会使用它.
递归定义 
递归定义指的是在定义中(直接或间接地)引用自身的定义. 乍看上去, 递归是一种很不合理的东西, 但实际上却很简单. 我们将用许多例子来刻画递归, 这些例子将反复出现.
第一个例子是阶乘, 它的定义是众所周知的.
https://telegra.ph/file/01d0ecea56dc593bce38d.png
我们可以将其直接地翻译为Scheme过程.
https://telegra.ph/file/0db066a956181fc578328.png
第二个例子是Fibonacci数列, 它的每一项, 可以通过简单的递归关系式确定.
https://telegra.ph/file/f475077e47a214a08364d.png
同样地, 将其翻译为Scheme过程是轻而易举的.
https://telegra.ph/file/97c845d4e62255f645274.png
第三个例子是最大公因数 (Euclid算法).
https://telegra.ph/file/edc4f3818b5f75e4d858f.png
Euclid算法在终止时能够给出正确的结果, 仰赖于以下事实.
https://telegra.ph/file/6f9658cd631e84c8bfd98.png
Euclid算法必然能够在有限步骤内终止, 是显然的, 因为根据余数的定义, 它小于除数b. 最粗略的估计告诉我们过程gcd最多进行b步, 一个更好的上界估计可以参看Lamé定理, 有趣的是, 它里面出现了Fibonacci数列.
第四个例子是一个互递归的例子. even?判断一个自然数是否是偶数, odd?判断一个自然数是否是奇数.
https://telegra.ph/file/fb7749d3a5eb4244650d4.png
局部定义 
现在我们引入局部定义, 这将进一步增强我们的表达能力.
首先我们引入let形式, 它的一般句法是(let ((<var> <exp>) ...) <exp>). 而其语义, 可以将其视为句法糖来解释. (let ((x0 e0) ...) body)就等价于((lambda (x0 ...) body) e0 ...).
现在我们给出一个简单的例子.
https://telegra.ph/file/9e7bf34d8758ce8fded4c.png
我们看到, let引入的绑定将顶层的绑定覆盖, 所以(let ((x 2)) (* x x))的值是4, 但是绑定不是赋值, 它不会修改外部的绑定, 所以当我们在REPL中对x求值时, 仍然得到0.
接着我们引入let*形式, 它和let有些类似, 实际上let*可以基于let定义.
let形式对于求值的顺序没有任何保证, 虽然现在看来它几乎不会造成任何问题, 因为我们还没有引入副作用. (let* ((x0 e0) (x1 e1) ...) body)等价于(let ((x0 e0)) (let* ((x1 e1) ...) body)), 而(let* () body)就等价于(let () body). 这使得let*具有明确的求值顺序, 即自左往右, 并且它逐次进行绑定.
现在我们给出一个简单的例子.
https://telegra.ph/file/8238ea63f96d7e78cadf7.png
如果把这里的let*换成let, 则会产生异常, 因为lambda表达式的形式参数应该是互不相同的.
let和let*的语义很容易理解, letrec的语义则不太容易了. 但是, 如果我们仅仅将letrec用于引入(互)递归的过程, 则不会造成什么困难, 现在我们就给出一个例子.
https://telegra.ph/file/4f6eace791dba74ed1045.png
letrec和let不同的是, 它的各右支可以引用左侧的变量 (但是有一定的限制, 不过在只使用letrec引入递归的过程的情况下, 没有什么问题).
最后, 我们引入lambda内部的define, 它的作用范围仅限于lambda表达式的体.
https://telegra.ph/file/96ebfc23280380906c99f.png
这是一个稍微复杂一点的例子, sqrt是一个利用迭代法求平方根的过程. 数学中的迭代法的大意是我们先给一个猜测值, 看它是否足够好, 如果不够好, 则改进它, 如此反复循环, 直至得到满意的值.
https://telegra.ph/file/b9ada616a69527984f7e5.png
这是迭代法求平方根的依据.
练习. 试说明, 以下过程也能正确计算Fibonacci数列的值, 也就是说, 对于每个自然数n, (fib-iter n)的值等于(fib n)的值.
https://telegra.ph/file/ee7c9a9d74c4bfdebf8b3.png
注记: 鉴于迭代 (不是迭代法) 这种模式经常出现, Scheme提供一种被称为"命名let"的句法糖, 比如说上面的fib-iter就可以改写为以下样式.
https://telegra.ph/file/3738d12c27e1e2680b137.png
高阶过程 
高阶过程指的是参数或者返回值是过程的过程. 我们当然已经看过这样的例子了, 即函数复合.
https://telegra.ph/file/08fe67368e8cf9065d23a.png
我们给这个过程取了个名字compose.
高阶过程之所以是必要的, 在于如果没有它们, 诸多概念压根就无法表达.
一个最基本的例子是求和记号, 我们将其翻译成直接的Scheme过程.
https://telegra.ph/file/657f8aa3d8bfef3b290f9.png
另一个非常基本的例子是以下的power过程.
https://telegra.ph/file/04791ddee4cc15373695c.png
((power n) f)的返回值是一个过程, 它就相当于将n个f复合在一起的函数.
练习. 以下表达式的值是多少?
https://telegra.ph/file/91a6674b95b13cdd3f021.png
计算行为 
https://telegra.ph/file/3fa9c67217c0d0d92e9aa.png
尽管在形式上, fact和gcd都是递归的, 但是当fact的输入n大于0时, 在得出(fact (- n 1))的结果之后, Scheme还必须"记住"将该值乘上n, fact的输入越大, 中间积累的记忆也就越多, 反观gcd, 如果b不是0, (gcd b (remainder a b))的结果直接就是(gcd a b)的结果, 记忆不会随着输入规模的增大而增长. 我们称像fact这样的过程呈现了递归计算行为, 而gcd这样的过程呈现了迭代计算行为.
注记: 虽然从原则上gcd描述了一种迭代式计算, 但语言的实现仍有可能指导机器产生递归计算行为.
练习. 观察以下过程.
https://telegra.ph/file/f16e895712310ce841754.png
参数k可以理解为fact求值过程中的记忆, 而(fact-cps n (lambda (v) v))的值就等于(fact n).
请证明对于以下过程fact-iter, 我们有(fact-iter n 1)的值等于(fact n).
并且, 试说明fact-iter和fact-cps之间的联系.
https://telegra.ph/file/9e7fff84f456237cfff65.png
提示: cps是延续传递风格 (continuation-passing style) 的缩写, 延续是对于剩余的计算 (即我们之前所说的"记忆") 的抽象, fact-cps的参数k就代表延续.
编程基础习题一 
学习什么不进行练习是不可能的, 学习编程也不例外, 所以我准备了许多有意思的习题. 在准备这些习题的时候, 我想到的是Halmos的Linear Algebra Problem Book这本书, 它也是我编制习题的标准. 也就是说, 要从一般的原理出发, 而不是从其对于其他领域的应用出发.
https://telegra.ph/file/7a850fd211bd845521764.jpg
编程基础习题二 
著名的逻辑学家Alonzo Church设计了lambda演算, 想要将其作为数学的基础. 若是要达成此目的, 那么须编码常见的数学对象, 比如说自然数. Church思考了一个方案, 现在被称为Church数码. 它的想法是, 还是请读者直接阅读代码吧.
https://telegra.ph/file/aa4208f8a09e01ef435bb.png
你能理解吗? 如果理解的话, 就请读者编写two, three, four.
好了, 如果读者学过一点数学的话, 大概会接触自然数系的构造. 我们知道, 后继是最基本的运算. 后继在Church数码中也是很容易的.
https://telegra.ph/file/67abca58979698f0410fe.png
有了后继, 加法其实就很简单了, 因为m+n不过就是对于m施行n次后继, 而Church编码下的n本来就是进行重复应用的.
真正有趣的一个话题是, 前继该怎么编写呢? 这可能是一个比较难的问题, 因为Church想了很久也没想出来. 在他快要放弃的时候, 他的学生, 同样也是著名的逻辑学家, 即Kleene, 终于想出来了. 这个故事和笑气有那么点关系, 也和拔智齿有那么点关系. 但是, 讲了也没什么意思.
https://telegra.ph/file/d8933d87fbec9f98effa9.png
这是Kleene的答案, 注意这里的cons是单参数的 (Currying的版本).
你能想出来一个更好的答案吗? (更简单, "效率"更高, ...)
第二章 列表处理
序对 
一个序对将恰好两个概念组合在一起. 并且, 给定一个序对, 我们可以将两个概念分离出来. 从此方面理解, 序对是最基本的组合手段.
Scheme提供了三个和序对相关的过程. cons用来构造序对, car是第一投影, cdr是第二投影. car和cdr这两个名字的由来是历史性的, 读者不必清楚.
https://telegra.ph/file/5161d9363482bf717c705.png
以上交互刻画了序对最基本的用法.
Scheme输出序对的方式有些微妙.
https://telegra.ph/file/bddc39a70cb542dbb53ca.png
当序对串起来的时候, 只有最后两个元素之间用.分隔.
实际上, 我们可以仅仅使用过程来实现序对.
https://telegra.ph/file/410fc529470dd8e5cd0f9.png
这模糊了我们心中过程和数据之间的界限.
注记: 任何Scheme系统都不会使用这种方式实现序对, 一方面出于效率问题, 另一方面在于我们想要在一般情况下区分序对和过程.
练习. 序对的一项切实的功用是用来返回多个值.
https://telegra.ph/file/c3386da4798cb85d4c83a.png
以上过程展现了所谓的"扩展Euclid算法", 试证明它的正确性.
列表 
空表是一个列表.
https://telegra.ph/file/c035cfd10e95750491692.png
quote形式就像是自然语言中的引用现象, 比如apple是一种水果, 而"apple"由5个字母组成. 对于(quote <datum>)求值得到<datum>.
但是, 读者应该注意到, ()并不是一个合法的句法. 尽管()也不会引起什么歧义, 但是Scheme就被设计成这样了.
quote形式是如此频繁地出现, 以至于存在一种很特殊的句法, 或许应该说这是词法层面的.
https://telegra.ph/file/140ed017331c2316c7c69.png
'()就相当于(quote ()), 实际上Scheme系统会将前者转换为后者.
对于列表lst和任意的Scheme值x, (cons x lst)也是一个列表, 而且它是将x加入lst的首部的列表.
https://telegra.ph/file/ecd18725c36bcb2f5c372.png
也就是说, 列表其实就是用序对串在一起的对象, 只不过最后要以空表结尾.
显然, 我们可以用car取得列表的首元素, cdr取得列表除首元素剩余的列表. 将car和cdr应用于空表会引起异常. (另一种Lisp方言Common Lisp中就不会, 而是返回空表.)
Scheme内置的函数list可以用来方便地构造列表.
https://telegra.ph/file/aa00b9c0876593b09716d.png
当然, 使用quote形式更加方便.
https://telegra.ph/file/98dcb26274c09b20873bf.png
但实际上quote形式更加一般, 可以引用各种各样的东西.
https://telegra.ph/file/4fb20a55fdee11638e8de.png
这里我们隐式地引入了类型为符号的对象.
显然, 列表可以用来编码各种各样的信息, 比如用来表示程序文本. 将其作为知识表示的手段, 是古典人工智能里最根本性的想法之一.
利用图像表示序对结构 
使用图像来表示序对结构 (也常被称为列表结构, 但不一定是列表), 常常有助于理解.
https://telegra.ph/file/6ec786bdb93546257388f.png
https://telegra.ph/file/56bf57756acacfc18e895.png
https://telegra.ph/file/389918bf8f89112f3d02f.png
练习. 画出对于以下Scheme表达式求值得到的序对结构的图像.
https://telegra.ph/file/74d16b64ac73e7866b7b5.png
定义于列表上的函数 
LISP是LISt Processing的缩写, 这显然暗示了LISP必然包含许多和列表有关的函数, 让我们现在就来检视一些.
最简单的函数大概就是length (尽管一个实际的实现里的length并不会那么简单, 因为它还要考虑"环路"的情况), 它大概可以定义如下.
https://telegra.ph/file/54514335f36463e8d42d6.png
以下是一些例子.
https://telegra.ph/file/31d98c8be3b463eb911a0.png
另外一个很简单的函数是list-ref, 它取出列表某个位置的元素, 以下是一种可能的定义.
https://telegra.ph/file/29182a3fe7a1f0646d140.png
然后是一些例子.
https://telegra.ph/file/7bd925fbf22fc92b95ed0.png
现在让我们来引入memq, memv和member, 但首先我们应该讨论一下谓词eq?, eqv?和equal?.
eq?, eqv?和equal?是Scheme中三种不同的判断相等性的谓词. 现在因为读者对于Scheme的理解还不够深入, 即便直截了当地讨论它们的区别, 或许也是没有益处的. 但读者可以这么区分它们, equal?是外延等价的近似物, eq?是内涵等价的近似物, eqv?是用来补充eq?的, 也是内涵等价的近似物. 比如, 请看以下例子.
https://telegra.ph/file/d8e1b4651d25db023ae2b.png
之所以会出现这样的情况, 是因为每次cons创建的都是"不同"的序对对象.
就此打住.
memq, memv和member仅仅是所用相等谓词不同而已, 其余都是一样的.
一种可能的memq定义如下.
https://telegra.ph/file/e783c9fea4264f1294818.png
它可以用来判断一个元素是否在列表中, 以下是一些例子.
https://telegra.ph/file/57b88cf3fbc53c9748e7e.png
正如名字所暗示的那样, memq用eq?比较相等, memv用eqv?, member用equal?.
接着, 让我们来看assq, assv和assoc.
在Scheme上下文中, 元素均为序对的列表被称为关联表 (association list), 它可以用来表示对应关系 (的外延).
以下是assq的一种可能定义.
https://telegra.ph/file/85608082588ceeb23914e.png
注记.
https://telegra.ph/file/a5e37dec941fdacc2024e.png
这也可以类推到c和r之间隔着3个4个a或d的情况. 但是更多, Scheme标准就不保证了.
接下来是一些例子.
https://telegra.ph/file/f20d5151844cfe5f3db1d.png
也就是说, assq可以根据每个序对的car部分 (一般被称为键) 进行索引.
练习.  编写过程assp, 它接受一个谓词和一个关联表, 然后返回第一个"键满足谓词"的序对, 如果这样的序对不存在, 就返回#f. 以下是一些例子.
https://telegra.ph/file/1b1a2212a022d583a6b0d.png
symbol?判断一个对象是否是符号, 类似的还有number?, pair?, procedure?等.
列表处理工具箱 
不难看出, 列表可以作为表示有限序列的通用媒介.  围绕这一媒介, 我们可以设计一组通用的处理过程. 这些过程可以自由地进行组合, 就像搭积木一样简单.
1. map
最具有代表性的列表处理过程应该就是map了, 它将一个函数应用于列表的每个元素上.
一种可能的map定义如下.
https://telegra.ph/file/7906579a37402042c9fde.png
其中null?是一个谓词, 对于空表返回#t, 否则返回#f.
想必读者对于map还不甚熟悉, 让我们来计算一个例子.
https://telegra.ph/file/18adf6a1f307f46aca807.png
2. filter
filter从列表中过滤出满足谓词的元素.
一种可能的filter定义如下.
https://telegra.ph/file/cdf064f386bf1b49b66de.png
以下是一些例子.
https://telegra.ph/file/2a73971b2b490bb1aa6ce.png
3. append
append将两个列表连接起来.
https://telegra.ph/file/835943a22827c7df7521c.png
注记. 从append的定义可以看出, 其实第二个参数不是列表也可以.
以下是一些例子.
https://telegra.ph/file/279df880ee976e1626a4b.png
4. reverse
reverse反转一个列表.
https://telegra.ph/file/ccae65a924a06c8fe27ec.png
以下是一些例子.
https://telegra.ph/file/497234ee6befc8eb6a84c.png
注记. reverse当然也可以按照如下方式定义, 就是效率看上去就会很尴尬.
https://telegra.ph/file/8a481b6bc2fd071094140.png
5. fold-left和fold-right
fold-left和fold-right, 在某种程度上说, 提供了对于列表处理过程的抽象.
因为fold-left和fold-right比较复杂, 我们先举例子.
https://telegra.ph/file/c188226d3b0b73f828699.png
https://telegra.ph/file/82ae8e46712915fff4aba.png
现在我们给出fold-left和fold-right的定义.
https://telegra.ph/file/52e0612d276a730b0b044.png
为了说明fold-left和fold-right何以为抽象, 我们用它们来重新定义之前的列表处理过程.
https://telegra.ph/file/406c0fc8dcfe8fceb06da.png
练习. 我们给出的fold-right的定义呈现出递归计算行为, 试将其改写为呈现迭代计算行为的版本.
列表处理工具箱续 
在"列表处理工具箱"之基础上, 我们继续来检视一些列表处理的习语.
1. append-map
append-map就类似于map, 它的一种可能定义如下.
https://telegra.ph/file/abe698916cc66b92f80e4.png
与map的定义相比, 其实append-map仅仅是将cons替换成了append.
注记. append-map又常被称为flatmap.
平凡的例子多看无益, 我们看看一个稍不平凡的应用吧.
https://telegra.ph/file/a177a0e75778d517371e0.png
product产生两个列表的"笛卡尔积", 以下是一些例子.
https://telegra.ph/file/4243d53a7ecfeddcaeb70.png
实际上, 我们可以定义更一般的product.
https://telegra.ph/file/0727d028b263e1c071294.png
当然了, 一般的product亦可以借助于fold-right之抽象来定义.
https://telegra.ph/file/c16f0edec28c2bd9efbb5.png
以下是一些例子.
https://telegra.ph/file/ab17ea68ab93170203072.png
当然了, 上面存在一些留待解释的Scheme机制.
一个是apply函数 (而不是形式), 还是举一些例子说明为好.
(apply + '(1 2 3))就相当于(+ 1 2 3), 所以结果是6.
apply函数也可以接受更多的参数, 比如
(apply + 1 2 '(3))也相当于(+ 1 2 3),
也就是说, 多出来的参数会按照顺序拼接到列表的前段.
另一个则是Scheme用以定义接受多个参数的过程的点记号.
理解点记号的方式在于将其视为"模式匹配", 不过"模式"在形式上非常受限.
比如(product . lst*)和(product)匹配会怎样, 要使得两个项相同, 就必须令lst*是();
(product . lst*)和(product (1 2) (a b))匹配会怎样, 要使得两个项相同, 就必须令lst*是((1 2) (a b)).
所以, product可以接受任意多个参数, 然后这些参数会形成一个列表, 此即lst*绑定至的值.
(define (product . lst*) <body>)应该算是句法糖, 脱糖的写法是
(define product (lambda lst* <body>)).
不过, 同样是按照模式匹配来理解.
同理, (define (foo a . x*) <body>)或等价版本(define foo (lambda (a . x*) <body>))定义了接受大于等于一个参数的过程, 并且第一个参数的值和a相关联, 其后的值形成列表与x*相关联.
(define (bar a b . x*) <body>)或等价版本(define bar (lambda (a b . x*) <body>))呢? 你肯定有答案了.
注记. 我必须承认这里的记号并非一致, 但希望读者能够领会我说的意思, 而不是纠结于细节.
2. 生成列表的过程.
这些过程的构造往往需要ad hoc的智慧, 是依照手头事情的特殊性得来的, 我们只看一个例子.
https://telegra.ph/file/033dccde67b96a8bcc4b5.png
init代表初值, next代表从一值转移到下一值的过程, pred是判断值是否合乎要求的谓词.
利用enumerate之抽象, 常可定义一些较为实用的过程, 比如iota.
https://telegra.ph/file/ac995cb9d1f11f2a3d920.png
以下是一些例子.
https://telegra.ph/file/2916d798836bdb0c86d65.png
练习. 编写过程foo, 以自然数n为输入, 产生所有满足和小于n的自然数三元组的列表.
https://telegra.ph/file/5d17ec5cf132168626bf1.png
节末注记. 对于列表处理, 我们侧重的是我们能够表达什么, 而不是效率事务. (事实上, 许多情况下, 列表处理无可救药地低效.) 在某种意义上, APL语言提供了类似的表达力. 在APL中, 一切都是矩阵, 而有许多用于处理矩阵的函数. APL语言实现的策略是尽可能综合这些函数, 比如合成两个操作为一个. 显然, 我们也可以在Scheme实现中内置这样的优化, 比如合成两趟map为一趟. (但是, 鉴于Scheme的灵活性, 为了保持正确的语义, 优化其实很难进行, 但我想对于受限的应用常能发挥很好的效用.)
列表处理习题一 
https://telegra.ph/file/8e91b533b4772d562e0ab.jpg
https://telegra.ph/file/0a7a96fc3035c77fb7109.jpg
列表处理习题二 
本题来源于SICP.
https://telegra.ph/file/59792db9e65bb8fb56372.jpg
列表处理习题三 
https://telegra.ph/file/107cdeb4f21e0b4a15475.png
https://telegra.ph/file/cb8e8344b95fe21ad50ce.png
https://telegra.ph/file/eb5ea5085f04cdaa93dbf.png
https://telegra.ph/file/73f697916c7c99f851165.png
https://telegra.ph/file/51bc8b944b8a3b41620e2.png
https://telegra.ph/file/c5f94cec7707c55c5f6fa.png
暂且就这么多吧.
列表处理习题四 
本次习题可能对于初学者比较困难, 量力而行. 在阅读之前, 读者最好了解一下什么是BNF文法.
https://telegra.ph/file/7ca31f546d68e0d1c5f64.png
https://telegra.ph/file/a81383e48219846510b91.png
https://telegra.ph/file/2a717fa365eed72b807ea.png
https://telegra.ph/file/529ca63eda6a89988111d.png
本来想想应该放一个参考实现, 想想还是算了. 为了能够简单明了地写出程序, 读者最好要了解一下模式匹配这样的语言功能, 但即便不使用它, 只要理解基本的原理, 写起来也很简单.
更新: Racket中的参考实现 (只考虑理解, 不考虑效率):
https://telegra.ph/file/9a60710915e3cf8ef562f.png
https://telegra.ph/file/67dd5ae1f5f49eb8e6569.png
https://telegra.ph/file/222b2e557cd4c1c3a0c1e.png
让我们来看一个例子 (加了一行输出中间过程的代码, 为了便于读者理解):
https://telegra.ph/file/702174cee997b64f7ebd4.png
https://telegra.ph/file/aa3509800492b47eaa821.png
https://telegra.ph/file/fb799e6d04f428c706dbd.png
其中用到了一个用于模式匹配的宏match:
https://telegra.ph/file/39e394aa8c67c3103a5eb.png
第三章 状态和对象
赋值和变动 
https://telegra.ph/file/a2615d02e57f7a8b69264.png
https://telegra.ph/file/c56756058d79c93b051da.png
https://telegra.ph/file/c5520126daad128466f13.png
https://telegra.ph/file/178fcf86e01d9da37dbf7.png
https://telegra.ph/file/3d294b9ce76f5de89b103.png
闭包和对象 
我们从一个例子开始.
https://telegra.ph/file/7e3e7235e4c71f01443dd.png
像counter这样的过程被有的人称之为let over lambda, 甚至有一本书以此为标题. 有的人喜欢称counter这样的过程为闭包, 但是实际上在概念上每个Scheme过程都是闭包. 有的人可能反对我的说法, 因为他们将闭包视为特定的实现技术, 但是那的确也是从概念上理解Scheme过程的正当做法.
一个闭包由过程的代码和创建过程所在的环境组成. 没有更多了. 这个名字理解起来是十分简单的, 也就是说, 过程的代码本身可能不是封闭的, 因为其可能含有自由变量, 但是通过将创建过程所在的环境容纳于考虑的范围之内, 过程就成为了封闭形式. 显然, 在实际的实现中, 并不需要保存整个环境, 只需要保存自由变量就够了.
counter见过以后, 让我们看看它的亲戚make-counter.
https://telegra.ph/file/79557faaf9318df9833c2.png
像make-counter这样的过程也被称为lambda over let over lambda, 原因也是显然的. 在对于(make-counter)求值时, x和0之间的绑定先被创建, 但是每次求值时的绑定也是不同的, 所以由make-counter创建的不同的counter之间不会相互干扰.
let over lambda式的过程常被称为「对象」, 这里的对象应该理解为带有局部状态的过程, 而且这个对象也与面向对象中的对象有关, 正所谓「闭包是穷人的对象, 对象是穷人的闭包」. 至于面向对象的本体论问题, 这不在我们书中交代. 对于Lisper/Schemer而言, 另一个重要的观念是对象之间通过「消息」进行交互, 我们之后再说.
消息传递 
在整本书中, 基本上我们都将消息表示为符号. 另外, 现在我们新的句法结构case.
https://telegra.ph/file/10a4949e8790f87129063.png
它就等价于
https://telegra.ph/file/366a5ce190da9c3bb97e2.png
else不是必须的, 但若出现只能出现在最后一行.
在某些实现中, 相等也可能使用equal?进行判断.
基本上我们使用case时<datum>只可能是符号.
让我们通过几个例子来熟悉case和消息传递.
第一个例子是counter的变种.
https://telegra.ph/file/d153832a1ea4b3a9c54ed.png
新的counter具有几种不同的机能, 当收到消息add1!时, 它计上一; 当收到消息init!时, 它重置计数; 当收到消息x时, 它反馈当前统计.
第二个例子是栈, 栈是一种「先进后出」的数据结构. 从现在开始, 我们将引入数据抽象和数据结构的概念.
提到数据抽象, 就不得不提到抽象数据类型. 抽象数据类型是由一系列创建, 解构, 操作数据的过程和它们所满足的约束定义的. 这就在数据及其具体实现之间建立了抽象边界. 如果一个程序使用抽象数据类型, 但不依赖于任何的实现细节, 我们就称这个程序尊重抽象边界. 尊重抽象边界的程序可以换用不同的实现而不会影响其机能, 这也是经常的事情, 尤其是在原型设计时. Scheme本身没有提供什么强制执行抽象边界的机制, 但是的确也有一些常见的方法. 不过, 在本书中, 我们完全不关心这点, 我们只希望读者理解抽象数据类型是什么而已.
数据结构则是一个多义词, 它可以指
1.  一个抽象数据类型;
2.  一个抽象的一个具体实现;
3.  一个实现的一个实例;
4.  一种特定的数据的物理表示.
对于作为抽象数据类型的栈而言, 最重要的操作是push!和pop!, push!压入一个元素进栈, pop!从栈中弹出一个元素. 另外重要的可能是判断栈是否为空的谓词empty-stack?.
现在我们给出一个简单的实现.
https://telegra.ph/file/81a676e5a4eb1af457783.png
以下是例子.
https://telegra.ph/file/4d83cf4dd4552bd1bb9a6.png
注记1. 我们可以编写几个额外的过程.
https://telegra.ph/file/f317c7d6759c2ff276368.png
这只是风格上的不同, 消息传递风格vs传统过程调用风格.
注记2. 当然, 我们还可以更简单一点.
https://telegra.ph/file/3ae2e3bae4b8f07464bc6.png
不过, 如果需要栈的多个实例, 这么做就不方便了.
注记3. 消息传递风格当然也可能有不同的变种, 比如以下的版本.
https://telegra.ph/file/fe5a489ecf29e187a5a32.png
这样的话, 每个栈对象接受消息之后, 得到的是「方法」 (面向对象的术语). 这么做的好处, 虽然这个例子里面完全没有用, 其中一个是可以引用对象自身. 当然, 我们需要一个辅助过程来调用方法.
https://telegra.ph/file/050557c6593af193c181e.png
我必须要说, 这些东西完全不是我的创制, 而是长久流传于Scheme程序员间的一些习语. 它们可以ad hoc地运用一些面向对象的机制, 但是我要说在Scheme中嵌入一个CLOS (Common Lisp Object System) 式的面向对象系统要比人们想象中的可能要容易得多, 不过这也不在本书中交代.
练习. 给我们的实现添加一些机能, 比如对于最大栈深度和当前栈深度的统计.
练习. 我们的实现基于列表, 另一种典型的实现基于向量, 请读者完成这个实现.
现在让我们引入向量, 在某种意义上它类似于列表, 可以用来表示有限序列.
过程vector, 类似于list, 可以创建向量.
https://telegra.ph/file/5f849d3e072a2440d6cbd.png
过程vector-ref, 类似于list-ref, 可以取得向量的分量.
https://telegra.ph/file/3a9a5aed48d0434529259.png
过程vector-length, 类似于length, 可以取得向量的长度.
https://telegra.ph/file/91108500cf0eb3169a828.png
vector-set!, 类似于list-set!, 可以修改向量的分量. (好吧, 我还没提过list-set!. 不过, 一般没有人使用这个过程.)
https://telegra.ph/file/b7650dd51026d27dad51e.png
练习. 编制过程list-set!.
过程vector?判断一个值是否是向量.
https://telegra.ph/file/7fc8fd41ee45648f11fa6.png
向量和列表的不同在于向量是随机可达的, 但列表不是. 回想一下list-ref的定义, 它需要经过许多序对才能到达目标, 而且这个序对的数目是由分量的位置决定的, 当然list-set!也是如此. 但是vector-ref和vector-set!不同, 它们可以在很短的常量时间内完成, 因为从计算机器的实现来说, 当你知道向量对象在什么位置的时候, 就可以直接计算出它每个分量的位置, 但是列表不行, 因为列表是由序对串在一起的.
练习. 实现队列, 一种「先进先出」的数据结构.
编程语言的邀请正式版
1 句法
1.1 抽象句法树 1.2 BNF文法 1.3 解释器的风味 
本章我们呈现了一个简单的编程语言, 以作为之后章节的基础.
1.1 抽象句法树
我们的程序常以程序文本作为输入或输出, 实际上是程序文本的表示. 至于如何表示程序, 让我们回忆句法的定义. 句法描述了由较小的语言成分构造较大的语言成分之规则. 这暗示着, 在最理想的情况下, 程序文本具有上下文无关的树结构, 即抽象句法树. 将程序文本从字符序列的表面形式转换为抽象句法树的过程被称为句法分析. 我们没有涵盖句法分析, 鉴于它不是编程语言的最核心内容.
https://telegra.ph/file/6c84dd0c889572d436e6b.png
1.2 BNF文法
BNF文法是描述句法的标准工具.
鉴于BNF文法总以变种形式出现, 我们以一个例子刻画其用法.
https://telegra.ph/file/6227aaf00a95f9d5a6590.png
以尖括号括起来的符号代表句法范畴, 即句法树的集合. 其余的符号代表字面本身. ::=的含义是定义,而|的含义近于或. 每个出现于右侧的句法范畴都意图被其一个元素替换以产生左侧的一个实例. 我们预先定义了一些范畴, <int>代表Scheme整数的集合, <bool>代表Scheme布尔的集合, <var>代表Scheme符号的集合.
1.3 解释器的风味
解释是赋予句法语义的过程. 一个解释器是一个程序, 其以程序文本为输入, 以值为输出. 于是, 解释器可以被视为对于其所解释的语言的语义的描述.
本节我们呈现了一个简单的解释器, 其为句法导向的结构递归. 为了方便地解构句法树, 我们引入了用于模式匹配的宏match, 其定义见附录.
https://telegra.ph/file/73ace20a35055fd6611c9.png
2 绑定
2.1 环境 
前一章的语言是无趣的, 因而本章我们为语言添加了绑定机制, 探索了绑定的行为.
至于如何实现绑定机制, 替换是一种直接的选择. 然而, 正确的替换的定义是微妙的, 并不如人们所想象的那样简单. 实际上, 历史上著名的逻辑学家, 比如Frege, Hilbert, Russell等, 都在这个问题上栽过跟头. 因此, 我们另辟蹊径, 为解释器添加了一个新的参数—环境.
环境是求值的数据上下文, 其确定了表达式的每个变量的意义. 一个环境是一个从变量的集合到值的集合的映射. 如果采用抽象数据类型的观点, 我们需要确定环境的接口以及其所需要满足的约束条件.
https://telegra.ph/file/ae0a4824e8f6d0c9ce7b2.png
现在我们给出环境的接口的两种不同实现.
https://telegra.ph/file/27140f9b75ed2def80044.png
2.2 一个带有绑定的语言 
本节我们呈现一个带有绑定的语言.
首先我们给出语言的句法.
https://telegra.ph/file/aac0c622bcfb57ff25d71.png
相较于前一章的语言的句法, <exp>的定义增加了两个产生式. 这两个产生式显然是对偶的, 一个引入变量绑定, 另一个则是变量引用.
从此刻起, 我们做出一个句法上的约定, 这可以免除许多微妙的麻烦, 即任何绑定结构都不应该引入与「关键词」相同的名字, 例如这里的关键词是if, let, +, -, *, =.
现在我们给出解释器, 注意它多了一个代表环境的参数. 实际上, 只有解释新增产生式的部分是有趣的.
https://telegra.ph/file/09aad6c88f8d02e612e1b.png
2.3 一个带有过程的语言 
什么是过程? 这个问题并不像看上去那么简单, 而且John McCarthy在设计Lisp时就掉进了坑里. 实际上, 在很长一段时间内, 动态作用域 (之后我们将实现动态作用域的语言) 一直被视为Lisp的本质特征之一, 而这招致了不少批评.
请看以下Scheme的读取求值输出循环交互.
https://telegra.ph/file/7ce3819ce53b1d4d977ea.png
这有什么可希奇的呢! 不过, 对于一个使用远古Lisp方言的程序员而言, 他很可能认为结果应该是12. 这是由于他会认为double的值是(lambda (x) (* x two)), 一个列表而已.
现代编程语言学家十分清楚这是完全错误的设计和看法, 但这对于当时的人们而言尚不明了. 实际上, 一个过程不仅是定义过程的代码本身, 还包括过程所在的环境. 这个环境确定了过程的自由变量的意义, 使其成为封闭形式. 因此, 人们将过程的代码 (形式参数和过程体) 和过程所在的环境合称为闭包 (closure).
如果一个语言的过程的自由变量的意义由创建过程的环境决定, 那么称这个语言采用了词法作用域. 「词法」应该理解为「可以从程序文本推断出来」, 这在动态的求值过程之前, 因而其也被称为静态作用域.
既然明白了什么是过程, 现在我们呈现一个带有过程的(词法作用域的)语言.
首先仍然是给出语言的句法.
https://telegra.ph/file/d07904992af464806f7fa.png
这个句法相较于前一节的语言, <exp>新增了两个产生式, 它们的确也是对偶的. 一个用于创建过程, 另一个用于应用过程.
现在我们给出解释器, 同样只有对于新增的产生式的解释是有趣的.
https://telegra.ph/file/0d9ab7c5f74e620584b70.png
我们将被解释的语言的闭包表示为Scheme的闭包, 这是一种过程性的表示. 如果我们采取数据抽象的观点, 将闭包视为抽象数据类型, 那么我们将闭包的创建和应用抽象为make-closure和apply-closure.
https://telegra.ph/file/7cf492a349df7b858f7e2.png
我们也可以更换闭包的具体表示, 例如以下的表示更加具体直接.
https://telegra.ph/file/36e6759a0b1ee76246925.png
我们想说的是, 没有真正的魔法! 用闭包表示闭包似乎是一种魔法, 但其也可以表示为寻常的数据结构.
注记: 这里的apply-closure使用let*的确没有什么必要, 但鉴于let并不规定求值顺序, 为了获得确定的控制流 (其一个好处在于保证不同的实现产生相同的行为), 我们还是使用了let*. 以后我们也将常常这么做.
让我们以一个有趣的例子结束本节.
https://telegra.ph/file/e1196d67d588ec80569db.png
它展示了不使用letrec编写递归过程的方法. (显然, 其中隐藏着一个不动点组合子.)
2.4 de Bruijn索引 
实际上, 足够敏锐的读者可能会发现我们可以在对于程序求值之前预测变量绑定于环境中的位置. 例如, 对于过程(lambda x (lambda y (+ x y)))而言, 当它依次被应用于两个具体的参数上去后, 将对于表达式(+ x y)求值, 不论在怎样的环境里被应用, 不论具体的参数如何, y的变量绑定一定出现于环境的最顶层, 而x的变量绑定一定出现于次顶层. 于是, 我们称y具有词法深度0, x具有词法深度1. 正如我们之前所言, 「词法」应该被理解为「可在动态的求值过程之前由程序文本静态地进行推断」.
https://telegra.ph/file/045628b69eb8e1d2451da.png
既然我们知道编译是保持语义的句法变换, 我们需要明白源语言和目标语言的句法和语义. 我们选择的源语言是前一节的语言, 而目标语言的句法和语义现在给出.
https://telegra.ph/file/87fda9bbb883c466aa2a4.png
https://telegra.ph/file/5da962dd58321c0c34365.png
这个解释器的结构与之前的仍然保持一致, 但一些细节发生了改变. 首先, 环境变成了「动态环境」, 它无需维护名字和值的序对, 而只需要压入值即可, 因为词法深度预测了变量的值的位置. 鉴于环境变成了动态环境, 因而make-closure和apply-closure也发生了相应的改变, 但那是很显然的.
在编写编译器之前, 我们或许还需要回答一个问题, 即de Bruijn索引有何好处呢? 在数学上, 我们知道一致的换名不改变函数的意义. 例如, (lambda x (* x x))和(lambda y (* y y))应该是相等的. 在逻辑上, 换名一般被称为α变换. 许多时候, 我们需要考虑α变换导出的等价关系 (α等价) 带来的等价类. 虽然我们不会给出证明, 但读者应该能够料想到, α等价的项的de Bruijn索引应该在字面上是相等的, 例如(lambda x (* x x))和(lambda y (* y y))的de Bruijn索引皆为(lambda (* (var 0) (var 0))), 这可以简化许多论证.
那么, 该如何编写这个编译器呢? 或许的确需要一点真正的聪明. 但是, 正如Alan Perlis (注: 第1届Turing奖获得者) 所言, 「我希望我们不要成为传教士. 不要觉得自己好像是圣经兜售者. 这个世界已经有太多那样的人了. 你对于计算的理解, 别人也能学会. 不要觉得好像成功计算的钥匙只掌握在你的手里.」
现在我们给出编译器的程序, 然后再解释其原理.
https://telegra.ph/file/785cbc7534c00aeb83934.png
实际上, 这不仅应该理解为编译, 更应该理解为「程序分析」, 而且是「静态分析」 (即求值前进行的分析). 只不过, 我们将分析的结果包裹在了一个语言里. 我们所想要分析的是变量的词法深度, 正如之前所说, 这其实是一种预测, 即对于变量绑定于动态的求值过程在环境中出现的位置的预测. 其正确与否的准则, 自然是预测和现实是否一致.
正是「预测和现实是否一致」启发了我们, 因为若我们直接运行程序, 就可以直接看到我们想要的正确答案, 那为什么不这么做呢? 的确没有任何理由阻止我们这么做, 而我们的编译器正进行着这样的操作. 只不过, 求值过程中的某些信息我们是不需要的, 比如变量被绑定至的值. 因此, 我们的编译器就没有计算这种信息. 实际上, 应该将这个编译器视为「抽象的解释器」, 它不过就是在「虚拟地运行程序」, 然后收集所需的信息. 「抽象解释」几乎是最重要的静态分析的方法, 但它最原初的想法并不复杂.
在这个编译器里, 环境被「静态环境」所代替. 静态环境只追踪变量的词法深度, 但不包含实际计算的值. 这个编译器也是一个句法导向的结构递归, 并且它的结构与解释器的结构如出一辙, 只是它的结果是程序而不是计算的值, 但这不是本质性的区别. 扩展环境的方式在编译器和解释器里是一致的, 这就是正确性的保证.
让我们以一个例子结束本节.
https://telegra.ph/file/5812d14e2ad1da82c6902.png
这个例子来源于前一节, 正说明何谓保持语义.
4 延续
4.1 延续和延续传递风格 
在第2章里, 我们运用环境这一概念对于绑定和过程的行为进行了建模. 在第3章里, 我们运用抽象内存这一概念对于变动和参数传递进行了建模. 在本章中, 我们将运用延续这一概念对于编程语言的控制行为进行建模.
延续是对于控制的抽象, 包裹了剩余的计算. 这个定义并不容易凭空理解, 让我们慢慢解释.
以下是两个典型的Scheme过程, fact和gcd.
https://telegra.ph/file/f23a11c6be0ed0bd03829.png
几乎每个Schemer都知道gcd是尾递归的, 而fact不是, 但不一定每个Schemer都能解释清楚原因.
让我们观察这两个过程的调用实例.
https://telegra.ph/file/59151394ac32301c5851e.png
可以看到, 在对于(fact 3)求值的过程中, 先是膨胀, 后是收缩. 这与对于(gcd 9 6)的求值过程很不一样, 因为不论怎样调用gcd, 其计算过程只会像一条直线. 而且, 可以想见, 随着自然数n的增长, (fact n)的最大膨胀程度也会线性地增长.
很容易解释fact的行为, 因为对于非零的自然数n, (fact n)就等价于(* n (fact (- n 1))), 在对于(fact (- n 1))求值的过程中, 系统必须「记住」要给最终的结果乘上n, 这种记忆, 或者说上下文, 不断地累积, 直到对于(fact 0)求值后开始收缩.
我们将这样的控制上下文称为延续, 它代表了当得到一个结果的时候, 之后该做什么以完成整个计算. 如果在求值过程中延续是有界的, 那么就称其呈现了迭代计算行为, 否则的话就称其呈现了递归计算行为. 计算行为和实际的形式无关, 例如虽然表面上fact和gcd都是递归的, 但是fact呈现了递归计算行为, 而gcd呈现了迭代计算行为.
所谓的延续传递风格变换 (CPS conversion/transformation) 可以使我们的讨论变得更加显然. 延续传递风格 (continuation-passing style) 是一种显式传递延续的风格, 也就是说, 将控制暴露出来.
https://telegra.ph/file/b1cd2c3ac62ab708950f2.png
这里的k均代表延续. 可以看到, gcd-cps不用修饰其延续, 而fact-cps需要记住给结果乘上n才行. 现在fact-cps也是尾递归的了, 但是本质上计算没有得到任何的简化, 因为它只是将原本在台面下发挥作用的延续搬到台面上而已.
接着, 请读者阅读fact-aps.
https://telegra.ph/file/5b3913a82d319367a386b.png
这里的a代表accumulator (累积器), 因此aps的意思是accumulator-passing style (累积器传递风格). 读者应该明白对于每个自然数n, (fact-aps n 1)就等于(fact n). 实际上, 读者可以将a视为对于延续的一种「表示」, 因为fact-cps的延续只是在累积需要乘上的一连串数字, 而这些数字之积就是a (如果最初的a是1的话). 这个想法不仅限于fact-cps和fact-aps.
关于对于每个自然数n和过程k, (fact-cps n k)等价于(k (fact n)), 以及关于对于每个自然数n和整数a, (fact-aps n a)等于(* (fact n) a)的证明, 见附录.
让我们再看一个例子, 比上面两个更复杂一些.
https://telegra.ph/file/dcdb2fda3e7245929851a.png
实际上, 按照语义, 先对于(fib (- n 1))求值还是先对于(fib (- n 2))求值都是可以的, 这也正是高级编程语言的优美之处, 它让我们从显式指定计算顺序中解放出来. 不过, 如果我们要将fib变换为延续传递风格的话, 我们就必须考虑安排顺序, 且非得给每个中间结果命名. 这听起来很像汇编, 不是吗? 的确, 在控制方面, 延续传递风格更接近于汇编而不是一般的高级编程语言. 关于以延续传递风格作为中间表示的编译已经有了很长的研究历史, 读者首先可以参考RABBIT: A Compiler for SCHEME以及Compiling with Continuations.
4.2 延续传递风格解释器 
为了简单起见, 本节我们从(按值调用的)lambda演算开始, 以下是句法.
https://telegra.ph/file/5b77c0868cc3920c2c428.png
然后是解释器, 现在延续也成为其参数.
https://telegra.ph/file/5ad98f67ae5464d1f25fe.png
实际上, 这就相当于对于原本的直接的解释器进行延续传递风格变换.
这个解释器的闭包和延续均以函数表示, 现在我们考虑将其转换为更加传统的数据结构, 这将使原本模糊的地方变得清晰起来.
https://telegra.ph/file/0ba29cd3dddceb6762338.png
从现在起, 我们开始考虑稍微复杂一些的语言, 即2.5节带有定义递归过程结构的语言.
不过, 我们将对于程序的结构作出一些改变. 首先我们将每个参数都变为全局的, 并使用赋值以在过程之间交流信息. 而且, 对于主要过程的调用都将出现在「尾位置」, 这等价于goto, 即控制的直接移交. (到本节末, 读者应该能够理解这句陈述的含义.) 于是, 这个程序的控制结构将非常类似于在一个汇编语言中编写解释器. 还有一个小小的观察, 实际上读者应该注意到延续可以安排成栈的结构, 而且其可以被视为编程语言运行时的堆栈的抽象化. (对于低层次行为的理解不必停留于低层次, 而可以通过更高层次的概念进行演绎.)
鉴于程序的长度, 我们逐块阅读.
https://telegra.ph/file/ac12d582f0cf2e5465321.png
这是所有全局变量的定义, 其中CLO即closure, CTX即context (即continuation), 以及栈的实现.
https://telegra.ph/file/5ed0110774f4907c2ecca.png
initialize!为求值做准备.
https://telegra.ph/file/e245cbe4a386b3806a0b0.png
INTERP是解释器的主体. 可以看到, 有的时候我们立即得到了所需要的值, 将其置于VAL之中, 接着我们APPLY_CTX以考虑接下来对于这个值做些什么; 另外一些时候, 我们需要考虑先对于某个子表达式求值, 并且给CTX添加之后要做什么的信息.
https://telegra.ph/file/9deff31bcedff0567ed40.png
APPLY_CTX考虑对于值进行怎样的加工. 和INTERP的情况类似, 有时我们得到了想要的值, 于是需要进一步加工; 另外的时候, 我们需要考虑对于什么表达式进行求值, 并给CTX添加控制信息.
https://telegra.ph/file/084d147f1c969b13b2139.png
APPLY_CLO不过是应用闭包CLO于值VAL.
https://telegra.ph/file/3a6b98c03e4078b26b916.png
剩下的是一些简单的关于延续的数据结构的定义.
现在让我们看一个对比的例子.
https://telegra.ph/file/6f6913ed411e1cab40758.png
https://telegra.ph/file/4d95375d1e16a38c64a8f.png
https://telegra.ph/file/5fe4f8579fb15bd473de0.png
从这个例子可以看到递归过程fact和<的不同性质, fact呈现了递归计算行为, 因为最大的栈深度随着输入的增长而线性地增长. 反观<, 最大的栈深度一直是3.
若我们追踪对于表达式(fact (- n 1))求值时的延续.
https://telegra.ph/file/1769981a7ed62e251115a.png
真正重要的原则是, 对于一个表达式的尾位置的表达式求值的延续, 应该与对于该表达式求值的延续是相等的, 这是因为尾位置的表达式的值, 就是整个表达式的值. 这也就是为什么说, 尾位置的过程调用就像goto一样, 因为无需添加任何需要做些什么的控制信息. 正是在于(fact (- n 1))没有出现在尾位置, 因而它必须记住还要做些什么.
编程语言的邀请遗弃版二
前言 
我一直有写一本编程语言导引的打算, 但是这个打算最多也只能算是部分完成了. 而且, 仅考虑完成的部分, 也不能令我满意, 毕竟它似乎对于不懂编程语言的人没有任何的吸引力. 诚然, 我也有些过于理想化了, 毕竟我回答不了"为什么要学习编程语言"这种问题.
我希望对于编程语言感兴趣的初中生高中生可以读读我写的材料. 至于大学生, 那还是读读Types and Programming Languages这种标准教材吧.
我们介绍编程语言的方法可以追溯至John McCarthy为了刻画Lisp的威力而编写的元解释器 (Lisp写的Lisp解释器). 一个解释器以程序文本 (的表示) 为输入, 以值为输出, 因而它可以被视为对于其所解释的语言的语义的描述. 这种方法所遇到的根本困难在于为了刻画某个编程语言的语义, 首先要刻画编写解释器所用的语言的语义. 我们没有为这个困难而烦扰, 因为我们依赖于读者对于语义的直觉. 自始至终, 我们都使用Scheme来编制程序, Scheme是Lisp的主要方言之一, 选择它的原因不过是因为用所谓的符号表达式表示抽象句法树很方便罢了.
我们的解释器在风格上近于大步操作语义, 或者说自然操作语义, 而不是小步操作语义. 我们很少证明关于程序的性质, 而是强调读者首先应该先从直觉上进行理解, 这对于以后严肃的学习完全是必要的.
句法 
以下内容均使用了Texmacs进行排版. Texmacs是一个很有意思的东西, 它的排版算法吸收了Tex的经验, 但是文档却是结构化的. 操作上则借鉴了Emacs, 可以通过Scheme进行扩展.
https://telegra.ph/file/80093bea7721c984e4936.jpg
https://telegra.ph/file/583ab60b806dfa8c4c83a.jpg
https://telegra.ph/file/5e386968b8a53a783ecbe.jpg
绑定 
https://telegra.ph/file/f85fdaa3ba66bf119d3b9.jpg
https://telegra.ph/file/fe2059b8c3a8d197ff21c.jpg
过程第一部分 
https://telegra.ph/file/df09b4e606700a3098e87.jpg
https://telegra.ph/file/7358f38d0efb35abeba14.jpg
https://telegra.ph/file/9e8f7c85a6d6f1b18b787.jpg
过程第二部分 
https://telegra.ph/file/e305e669a68117c7a4a32.jpg
https://telegra.ph/file/1a827e3fc9e3bda872d6e.jpg
https://telegra.ph/file/f67f6d4019203652986a5.jpg
https://telegra.ph/file/1e8dadfc98961b7eebe89.jpg
过程第三部分 
https://telegra.ph/file/5a65bdb353a290901756b.jpg
https://telegra.ph/file/cf21a12c037e286c0f828.jpg
https://telegra.ph/file/a703fe5d89bd9eb741be1.jpg
过程第四部分 
https://telegra.ph/file/41b4408abb30c98fa339a.jpg
https://telegra.ph/file/8bfeb520a4851cc828cd7.jpg
编程语言的邀请遗弃版一
编程语言的邀请12 
https://telegra.ph/file/b4f4c21690020badb95bf.jpg
编程语言的邀请13 
https://telegra.ph/file/8d886617e382fc3969fb1.jpg
https://telegra.ph/file/11636438d3f3b0ae37ee0.jpg
https://telegra.ph/file/5d263f795a1a46c1a4f9d.jpg
https://telegra.ph/file/6fb09050ad15b97258321.jpg
编程语言的邀请14 
https://telegra.ph/file/63b73e5317fb58b3af792.jpg
https://telegra.ph/file/a4f0a3dbeb3d34dc4d88b.jpg
https://telegra.ph/file/54a7ea7dbb1ba49076de4.jpg
https://telegra.ph/file/75de8aeb93638caa804f0.jpg
编程语言的邀请15 
https://telegra.ph/file/1d34d195df0ab000705ee.jpg
编程语言的邀请18 
https://telegra.ph/file/e2aa7e8b28a6bbca6ccda.jpg
https://telegra.ph/file/5a6a49a083167c08d5942.jpg
编程语言的邀请19 
https://telegra.ph/file/ac55d460881a8f8b6b807.jpg
https://telegra.ph/file/a08f0fec875b6a4658afb.jpg
https://telegra.ph/file/411215b5791393a556624.jpg
编程语言的邀请20 
https://telegra.ph/file/0bab52d19a54d13827ca1.jpg
https://telegra.ph/file/2ef7178d6ff11363a1c9c.jpg
https://telegra.ph/file/30640076c32db71788112.jpg
古典人工智能的邀请
古典人工智能的邀请0 模式匹配 
这些内容并非标准, 只反映了作者的个人见解.
古典人工智能是研究如何使用编程语言表达人类对于自身思考过程的高层次描述的领域. 也就是说, 它不是数学, 逻辑, 算法的附庸, 尽管它可能与这些学科有着紧密的联系. 对于编程语言的研究在古典人工智能中处于核心地位, 因为本质上古典人工智能的问题是表达力的问题. 而且, 从历史看来, 古典人工智能尤其偏爱Lisp族语言, 这很大程度上是因为其灵活性, 尤其是作为通用媒介的符号表达式 (S-exp, S-expression, symbolic expression) 的灵活性. 这使得在Lisp中嵌入语言自然而流畅.
在古典人工智能中首先发展起来的是模式匹配和基于规则的程序, 这是因为很大程度上人类的知识也是基于模式编码的. 比如modus ponens指的是如果有了P和P->Q, 就可以断言Q. 这里的P和Q是元语言的变量, 如果将其一致地替换为对象语言的句子, 就能得到modus ponens的实例. 但是使用modus ponens时, 人类并不预先知道要运用其怎样的实例, 而实际上是通过模式匹配提取出潜在的可能性, 即P和Q是什么的时候可以运用modus ponens.
另一个典型的例子是符号微分, 它也是John McCarthy设计Lisp的初衷之一, 以下是一个具体的Scheme程序.
https://telegra.ph/file/9eead0ba8211a81292e9d.png
以下是一些例子.
https://telegra.ph/file/f21bd084da5d37e3f2384.png
这个简短的程序只处理由数字, 变量, 加法, 乘法任意复合的表达式的符号微分, 但已经充分说明了问题. match是一个模式匹配的宏, 它用以解构表达式 (或者说句法树). 实际上, 该程序不过是微分法则的直接翻译而已. Alan Perlis说过一句名言, A programming language is low level when its programs require attention to the irrelevant. 古典人工智能的终极目标正是以直接的方式表达一切人类所需要表达的想法和概念, 不论其是否和计算有关.
或许一个显而易见的问题是为什么要使用编程语言进行表达. 对于作者而言, 编程语言是一种精确媒介. 在使用编程语言进行表达的过程中, 一切思维中错误和不准确的地方很容易被发现. 这对于让别人理解自己的想法也是好的. 事实上, 在数学和物理的表述中, 已经有太多不准确的地方了, 它们已经对于许多人造成了不可挽回的伤害.
附余
编程语言书籍推荐 
感觉最近要忙于学习, 暂不更新. 对于有志于研究编程语言者, 我推荐下列书籍.
程序设计入门
1. Structure and Interpretation of Computer Programs
虽老但好, 不减当年风采. 通过阅读此书, 读者可期对于计算机整体拥有全面深入的了解.
(有中文翻译, 但文学性部分翻译全是错的, 技术性部分却没有太大问题.)
2. The Little Schemer; The Seasoned Schemer
采用对话体写成, 饶富趣味. 有些内容相当值得一读, 比如对于应用序y算子的推导.
(The Little Schemer最近也有中文译本了.)
3. How to Design Programs
较新的书, 带有现代美式计算机教材特有的啰嗦, 但是内容没有什么问题, 甚至涵盖了前面书中没讲但重要的东西, 即便读者可以从其他地方学到.
(有第一版的中文翻译, 但第二版也有中文翻译, 但没有电子版.)
4. Programming in Standard ML
虽然没有写完, 但已经写了的部分可以读一读. Standard ML是编程语言人的智慧结晶, 从中可以学到许多.
(没有中文翻译.)
编程语言入门
1. Essentials of Programming Languages
较为浅易, 几乎没有任何定理和证明, 适合非常不擅长数学的人阅读, 或是作为初次学习编程语言获得对于其大概的直觉印象.
(没有中文翻译, 我自己翻译了一小部分.)
2. Programming Languages: Application and Interpretation
可以看作是受到EoPL启发而产生的书籍, 比EoPL更为现代, 内容更为丰富.
(有还算可以的中文翻译.)
3. Types and Programming Languages
凡治编程语言者, 无不听闻其大名. 这本书就是如此重要, 任何学习编程语言的人都不应该错过. 而且, 这本书不难.
(有中文翻译, 但还不如没有.)
4. Practical Foundations for Programming Languages
Robert Harper的专著, 对于编程语言的百科全书式处理, 强烈地反映了其个人的见解.
(没有中文翻译.)
5. Semantics Engineering with PLT Redex
欲对于抽象机器有所了解, 应阅读第一部分, 而第二部分是对于第一部分内容的程序化机械化处理. 第三部分可不读, 因为是第二部分引入的工具的应用.
(没有中文翻译.)
6. Software Foundations第一卷和第二卷
使用证明助手Coq对于逻辑和编程语言的介绍.
(有中文翻译.)
7. Programming Language Foundations in Agda
Software Foundations的第二卷的Agda版本
(有中文翻译.)
8. Proofs and Types
本书更偏向逻辑学一些, 但本来逻辑学和编程语言就不分家, 一部分原因是Curry-Howard同构.
(没有中文翻译.)
可计算性与计算复杂度
1. Computability and Complexity (Neil Jones)
本书是一本奇书, 将编程语言人的观念引入可计算性与计算复杂度理论中.
(没有中文翻译.)
部分求值
1. Partial Evaluation and Automatic Program Generation
部分求值其实就是程序特化, 就是固定什么参数不变.
(没有中文翻译.)
好了, 先就这么多吧.
编译器写作日记
编译器写作日记一 
其实这大概是朝花夕拾罢. 曾经年少的朝气, 似乎已不可失而复得. 上一次我写编译器的时候, 学习编程不过一年多. 那时我才读了大半的SICP, 两本小人书The Little Schemer和The Seasoned Schemer, 以及一部分的Essentials of Programming Languages. 或许杂七杂八的书也读了些, 不过那大抵还是年少轻狂之时, 一路突飞猛进. 其实上一回的尝试我编译器只写了一半, 到以前的IUB P423/523课程的中间部分, 后面是全写完了, 前面到寄存器分配的时候是怎么也写不下去 (而且再之前的基本块划分我写得也很不满意), 于是就此搁笔. 当然, 那时还有一个谜到现在仍然是一个谜, 即letrec和letrec*的语义. 想来, 那也是很多内容了, 比如闭包变换和优化, 赋值变换, 常量传播 (虽然现在想想可能不保持语义, 但是大部分编译器的做法似乎也和我一样) 之类的.
今天翻出来以前写的编译器重写, 其实几乎没有多少改动, 因为那时我的程序实在是过于干净, 没有必要再改. 我只是修改了一些数据结构的表示. 之前的编译器有一个非常奇怪的地方, 可能除了Lisp程序员之外都干不出这样的事情, 那就是编译器的中间表示仍然几乎是合法的Lisp程序, 可以直接扔进REPL里跑. 我把alpha变换之后的变量表示修改了, 比如以前是temp.13, 那么现在就是(uvar temp 13). 或许有人可能会担心效率问题, 但是这一个变量的表示是由所有变量的出现所共享的, 所以没有问题. (正所谓, S-exp可不是树.) 而且, 我发现从理论上来说那些和集合操作有关的辅助过程也并不需要修改, 因为的确这些变量的出现都共享一处表示.
另外一个变动就是原始过程和非原始过程的应用目前有了新的句法, 这看起来也是更加复杂了, 总之离能够直接扔进REPL里跑越来越远. 不过, 或许可以写一个简单的变换来实现这点.
我还意识到上一次我写编译器的时候犯了一个很大的错误, 根本原因还是在于没有完全遵循句法. (我可以说我是被王垠带偏了吗, 而且我发现他的编译器里面也有非常离谱的一些错误和写法. 突然想到, 我和王垠还吵过一天架, 很有可能改变了历史进程, 笑.) 一个原始过程的应用, 原始过程的名字本身应该视为一个特殊的元素看待, 之前的编译器里我都把它当作变量处理了. 不仅写起来会非常别扭, 而且我还怀疑我引入了一些subtle的bug.
大致上想说的就这么一点, 那么现在看看第一个编译器pass (或者说我喜欢叫做小编译器) parse-scheme的源语言和目标语言的句法.
https://telegra.ph/file/7afe72144be8f0adbbf5f.png
值得注意的是, 这里的fixnum是一个61位的有符号整数, 因为拿了3位去做运行时标记 (Scheme是一个动态类型语言).
https://telegra.ph/file/b0a055efb8b97572fa3cb.png
可以看到, 句法的复杂度下降非常之多. 这些小编译器做的事情, 不过就是分析和变换, 将语言变得越来越简单, 同时保持语义.
看个例子吧, 虽然完全没有体现任何东西, 但是我现在无心编制测试用例.
https://telegra.ph/file/8e450a13b33b399cacd01.png
这数年光景只若南柯一梦. 用了五年时间, 我以几乎垫底的成绩从数学系毕业了 (虽然我承认我几乎没有去上过任何课, 除了期末考试突击考场之外, 我都躺在床上). 想要申请学校, 却不知申请什么好.
